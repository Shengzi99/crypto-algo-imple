#include <stdint.h>
#include <stdio.h>
#include <string.h>

#define U8TO32(b0, b1, b2, b3) ( ((uint32_t)(b0)) | (((uint32_t)(b1))<<8) | (((uint32_t)(b2))<<16) | (((uint32_t)(b3))<<24) )
#define U32TO8(U32, U8P) {(U8P)[3]=(uint8_t)(U32); (U8P)[2]=(uint8_t)((U32)>>8); (U8P)[1]=(uint8_t)((U32)>>16); (U8P)[0]=(uint8_t)((U32)>>24);}
#define ROTL32(x, n) (( x<<n  ) | (x>>(32-n)))

const uint32_t CK[32] = {
    0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269,
    0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9,
    0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249,
    0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9,
    0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229,
    0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299,
    0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209,
    0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279
};
const uint8_t S_box[256] = {
	0xD6,0x90,0xE9,0xFE,0xCC,0xE1,0x3D,0xB7,0x16,0xB6,0x14,0xC2,0x28,0xFB,0x2C,0x05,
	0x2B,0x67,0x9A,0x76,0x2A,0xBE,0x04,0xC3,0xAA,0x44,0x13,0x26,0x49,0x86,0x06,0x99,
	0x9C,0x42,0x50,0xF4,0x91,0xEF,0x98,0x7A,0x33,0x54,0x0B,0x43,0xED,0xCF,0xAC,0x62,
	0xE4,0xB3,0x1C,0xA9,0xC9,0x08,0xe8,0x95,0x80,0xDF,0x94,0xFA,0x75,0x8F,0x3F,0xA6,
	0x47,0x07,0xA7,0xFC,0xF3,0x73,0x17,0xBA,0x83,0x59,0x3C,0x19,0xE6,0x85,0x4F,0xA8,
	0x68,0x6B,0x81,0xB2,0x71,0x64,0xDA,0x8B,0xF8,0xEB,0x0F,0x4B,0x70,0x56,0x9d,0x35,
	0x1E,0x24,0x0E,0x5E,0x63,0x58,0xD1,0xA2,0x25,0x22,0x7C,0x3B,0x01,0x21,0x78,0x87,
	0xD4,0x00,0x46,0x57,0x9F,0xD3,0x27,0x52,0x4C,0x36,0x02,0xE7,0xA0,0xc4,0xC8,0x9E,
	0xEA,0xBF,0x8A,0xD2,0x40,0xc7,0x38,0xB5,0xA3,0xF7,0xF2,0xCE,0xF9,0x61,0x15,0xA1,
	0xE0,0xAE,0x5D,0xA4,0x9B,0x34,0x1A,0x55,0xAD,0x93,0x32,0x30,0xF5,0x8C,0xB1,0xE3,
	0x1D,0xF6,0xE2,0x2E,0x82,0x66,0xCA,0x60,0xC0,0x29,0x23,0xAB,0x0D,0x53,0x4E,0x6F,
	0xD5,0xDB,0x37,0x45,0xDE,0xFD,0x8E,0x2F,0x03,0xFF,0x6A,0x72,0x6D,0x6C,0x5B,0x51,
	0x8D,0x1b,0xAF,0x92,0xBB,0xDD,0xBC,0x7F,0x11,0xD9,0x5C,0x41,0x1F,0x10,0x5A,0xD8,
	0x0A,0xC1,0x31,0x88,0xA5,0xCD,0x7B,0xBD,0x2D,0x74,0xD0,0x12,0xB8,0xE5,0xB4,0xB0,
	0x89,0x69,0x97,0x4A,0x0C,0x96,0x77,0x7E,0x65,0xB9,0xF1,0x09,0xC5,0x6E,0xC6,0x84,
	0x18,0xF0,0x7D,0xEC,0x3A,0xDC,0x4D,0x20,0x79,0xEE,0x5F,0x3E,0xD7,0xCB,0x39,0x48
};


static inline uint32_t _round_func(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3, uint32_t rk)
{
    uint32_t permu_T = x1 ^ x2 ^ x3 ^ rk;
    // Nonlinear transformation τ
    permu_T = U8TO32(S_box[(uint8_t)(permu_T)], S_box[(uint8_t)(permu_T>>8)], S_box[(uint8_t)(permu_T>>16)], S_box[(uint8_t)(permu_T>>24)]);
    // Linear transformation L
    permu_T = permu_T ^ ROTL32(permu_T, 2) ^ ROTL32(permu_T, 10) ^ ROTL32(permu_T, 18) ^ ROTL32(permu_T, 24);
    return x0 ^ permu_T;
}

static inline uint32_t _round_func_key_expd(uint32_t k0, uint32_t k1, uint32_t k2, uint32_t k3, uint32_t ck)
{
    uint32_t permu_T = k1 ^ k2 ^ k3 ^ ck;
    // Nonlinear transformation τ
    permu_T = U8TO32(S_box[(uint8_t)(permu_T)], S_box[(uint8_t)(permu_T>>8)], S_box[(uint8_t)(permu_T>>16)], S_box[(uint8_t)(permu_T>>24)]);
    // Linear transformation L
    permu_T = permu_T ^ ROTL32(permu_T, 13) ^ ROTL32(permu_T, 23);
    return k0 ^ permu_T;
}

void SM4_KeyExpd_naive(const uint8_t* key, uint32_t* key_schedule)
{
    uint32_t k0=U8TO32(key[3], key[2], key[1], key[0]) ^ 0xA3B1BAC6, 
             k1=U8TO32(key[7], key[6], key[5], key[4]) ^ 0x56AA3350,
             k2=U8TO32(key[11], key[10], key[9], key[8]) ^ 0X677D9197,
             k3=U8TO32(key[15], key[14], key[13], key[12]) ^ 0XB27022DC, tmp;
    for(int i=0; i<32; i++)
    {
        tmp = _round_func_key_expd(k0, k1, k2, k3, CK[i]);
        key_schedule[i]=tmp; k0=k1; k1=k2; k2=k3; k3=tmp;
    }
}

void SM4_Encrypt_naive(const uint8_t* plaintext, const uint32_t* key_schedule, uint8_t* ciphertext)
{   
    uint32_t x0=U8TO32(plaintext[3], plaintext[2], plaintext[1], plaintext[0]), 
             x1=U8TO32(plaintext[7], plaintext[6], plaintext[5], plaintext[4]),
             x2=U8TO32(plaintext[11], plaintext[10], plaintext[9], plaintext[8]),
             x3=U8TO32(plaintext[15], plaintext[14], plaintext[13], plaintext[12]), tmp;
    for(int i=0; i<32; i++)
    {
        tmp = _round_func(x0, x1, x2, x3, key_schedule[i]);
        x0=x1; x1=x2; x2=x3; x3=tmp;
    }
    U32TO8(x3, ciphertext)
    U32TO8(x2, ciphertext+4)
    U32TO8(x1, ciphertext+8)
    U32TO8(x0, ciphertext+12)
}

void SM4_Decrypt_naive(const uint8_t* ciphertext, const uint32_t* key_schedule, uint8_t* plaintext)
{
    uint32_t x0=U8TO32(ciphertext[3], ciphertext[2], ciphertext[1], ciphertext[0]), 
             x1=U8TO32(ciphertext[7], ciphertext[6], ciphertext[5], ciphertext[4]),
             x2=U8TO32(ciphertext[11], ciphertext[10], ciphertext[9], ciphertext[8]),
             x3=U8TO32(ciphertext[15], ciphertext[14], ciphertext[13], ciphertext[12]), tmp;
    for(int i=31; i>=0; i--)
    {
        tmp = _round_func(x0, x1, x2, x3, key_schedule[i]);
        x0=x1; x1=x2; x2=x3; x3=tmp;
    }
    U32TO8(x3, plaintext)
    U32TO8(x2, plaintext+4)
    U32TO8(x1, plaintext+8)
    U32TO8(x0, plaintext+12)
}